(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.MatrxRadar = factory());
}(this, (function () { 'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createSvgElement(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function setXlinkAttribute(node, attribute, value) {
		node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				handler.__calling = true;
				handler.call(this, data);
				handler.__calling = false;
			}
		}
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._bind = options._bind;

		component.options = options;
		component.root = options.root || component;
		component.store = component.root.store || options.store;
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		this.root._lock = true;
		callAll(this.root._beforecreate);
		callAll(this.root._oncreate);
		callAll(this.root._aftercreate);
		this.root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var proto = {
		destroy,
		get,
		fire,
		on,
		set,
		_recompute: noop,
		_set,
		_mount,
		_differs
	};

	/* src/Arc.html generated by Svelte v2.7.2 */

	function p1x({innerRadius, centerX, startRadians}) {
		return centerX + (innerRadius * Math.sin(startRadians));
	}

	function p1y({innerRadius, centerY, startRadians}) {
		return centerY - (innerRadius * Math.cos(startRadians));
	}

	function p2x({innerRadius, centerX, endRadians}) {
		return centerX + (innerRadius * Math.sin(endRadians));
	}

	function p2y({innerRadius, centerY, endRadians}) {
		return centerY - (innerRadius * Math.cos(endRadians));
	}

	function p3x({outerRadius, centerX, endRadians}) {
		return centerX + (outerRadius * Math.sin(endRadians));
	}

	function p3y({outerRadius, centerY, endRadians}) {
		return centerY - (outerRadius * Math.cos(endRadians));
	}

	function p4x({outerRadius, centerX, startRadians}) {
		return centerX + (outerRadius * Math.sin(startRadians));
	}

	function p4y({outerRadius, centerY, startRadians}) {
		return centerY - (outerRadius * Math.cos(startRadians));
	}

	function arcSweep({endRadians, startRadians}) {
		return (endRadians - startRadians <= Math.PI) ? "0" : "1";
	}

	function pMRadius({innerRadius, outerRadius}) {
		return (innerRadius + outerRadius) / 2;
	}

	function pMStartX({pMRadius, centerX, startRadians}) {
		return centerX + (pMRadius * Math.sin(startRadians));
	}

	function pMStartY({pMRadius, centerY, startRadians}) {
		return centerY - (pMRadius * Math.cos(startRadians));
	}

	function pMEndX({pMRadius, centerX, endRadians}) {
		return centerX + (pMRadius * Math.sin(endRadians));
	}

	function pMEndY({pMRadius, centerY, endRadians}) {
		return centerY - (pMRadius * Math.cos(endRadians));
	}

	function data() {
	  return {
	    id: 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	        var r = crypto.getRandomValues(new Uint8Array(1))[0]%16|0, v = c == 'x' ? r : (r&0x3|0x8);
	        return v.toString(16)
	    }),
	    opacity: 1,
	    label: "",
	    fontSize: 1,
	  }
	}
	function create_main_fragment(component, ctx) {
		var g, defs, path, path_d_value, text, textPath, text_1, textPath_xlink_href_value;

		function select_block_type(ctx) {
			if ((ctx.startRadians >= ctx.Math.PI / 2) && (ctx.endRadians <= 3 * ctx.Math.PI / 2)) return create_if_block;
			return create_if_block_1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c() {
				g = createSvgElement("g");
				defs = createSvgElement("defs");
				if_block.c();
				path = createSvgElement("path");
				text = createSvgElement("text");
				textPath = createSvgElement("textPath");
				text_1 = createText(ctx.label);
				setAttribute(path, "fill", ctx.fill);
				setAttribute(path, "opacity", ctx.opacity);
				setAttribute(path, "stroke", ctx.stroke);
				setAttribute(path, "stroke-width", ctx.strokeWidth);
				setAttribute(path, "stroke-linecap", "square");
				setAttribute(path, "d", path_d_value = "\n      M " + ctx.p1x + " " + ctx.p1y + "\n      A " + ctx.innerRadius + " " + ctx.innerRadius + " 0 " + ctx.arcSweep + " 1 " + ctx.p2x + " " + ctx.p2y + "\n      L " + ctx.p3x + " " + ctx.p3y + "\n      A " + ctx.outerRadius + " " + ctx.outerRadius + " 1 " + ctx.arcSweep + " 0 " + ctx.p4x + " " + ctx.p4y + "\n      L " + ctx.p1x + " " + ctx.p1y + "\n    ");
				setXlinkAttribute(textPath, "xlink:href", textPath_xlink_href_value = "#" + ctx.id);
				setAttribute(textPath, "dominant-baseline", "middle");
				setAttribute(textPath, "text-anchor", "middle");
				setAttribute(textPath, "startOffset", "50%");
				setAttribute(textPath, "fill", ctx.fontColor);
				setAttribute(text, "font-size", ctx.fontSize);
			},

			m(target, anchor) {
				insertNode(g, target, anchor);
				appendNode(defs, g);
				if_block.m(defs, null);
				appendNode(path, g);
				appendNode(text, g);
				appendNode(textPath, text);
				appendNode(text_1, textPath);
			},

			p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(defs, null);
				}

				if (changed.fill) {
					setAttribute(path, "fill", ctx.fill);
				}

				if (changed.opacity) {
					setAttribute(path, "opacity", ctx.opacity);
				}

				if (changed.stroke) {
					setAttribute(path, "stroke", ctx.stroke);
				}

				if (changed.strokeWidth) {
					setAttribute(path, "stroke-width", ctx.strokeWidth);
				}

				if ((changed.p1x || changed.p1y || changed.innerRadius || changed.arcSweep || changed.p2x || changed.p2y || changed.p3x || changed.p3y || changed.outerRadius || changed.p4x || changed.p4y) && path_d_value !== (path_d_value = "\n      M " + ctx.p1x + " " + ctx.p1y + "\n      A " + ctx.innerRadius + " " + ctx.innerRadius + " 0 " + ctx.arcSweep + " 1 " + ctx.p2x + " " + ctx.p2y + "\n      L " + ctx.p3x + " " + ctx.p3y + "\n      A " + ctx.outerRadius + " " + ctx.outerRadius + " 1 " + ctx.arcSweep + " 0 " + ctx.p4x + " " + ctx.p4y + "\n      L " + ctx.p1x + " " + ctx.p1y + "\n    ")) {
					setAttribute(path, "d", path_d_value);
				}

				if (changed.label) {
					text_1.data = ctx.label;
				}

				if ((changed.id) && textPath_xlink_href_value !== (textPath_xlink_href_value = "#" + ctx.id)) {
					setXlinkAttribute(textPath, "xlink:href", textPath_xlink_href_value);
				}

				if (changed.fontColor) {
					setAttribute(textPath, "fill", ctx.fontColor);
				}

				if (changed.fontSize) {
					setAttribute(text, "font-size", ctx.fontSize);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(g);
				}

				if_block.d();
			}
		};
	}

	// (3:4) {#if (startRadians >= Math.PI / 2) && (endRadians <= 3 * Math.PI / 2)}
	function create_if_block(component, ctx) {
		var path, path_d_value;

		return {
			c() {
				path = createSvgElement("path");
				setAttribute(path, "id", ctx.id);
				setAttribute(path, "d", path_d_value = "\n          M " + ctx.pMEndX + " " + ctx.pMEndY + "\n          A " + ctx.pMRadius + " " + ctx.pMRadius + " 1 " + ctx.arcSweep + " 0 " + ctx.pMStartX + " " + ctx.pMStartY + "\n        ");
			},

			m(target, anchor) {
				insertNode(path, target, anchor);
			},

			p(changed, ctx) {
				if (changed.id) {
					setAttribute(path, "id", ctx.id);
				}

				if ((changed.pMEndX || changed.pMEndY || changed.pMRadius || changed.arcSweep || changed.pMStartX || changed.pMStartY) && path_d_value !== (path_d_value = "\n          M " + ctx.pMEndX + " " + ctx.pMEndY + "\n          A " + ctx.pMRadius + " " + ctx.pMRadius + " 1 " + ctx.arcSweep + " 0 " + ctx.pMStartX + " " + ctx.pMStartY + "\n        ")) {
					setAttribute(path, "d", path_d_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(path);
				}
			}
		};
	}

	// (11:4) {:else}
	function create_if_block_1(component, ctx) {
		var path, path_d_value;

		return {
			c() {
				path = createSvgElement("path");
				setAttribute(path, "id", ctx.id);
				setAttribute(path, "d", path_d_value = "\n          M " + ctx.pMStartX + " " + ctx.pMStartY + "\n          A " + ctx.pMRadius + " " + ctx.pMRadius + " 0 " + ctx.arcSweep + " 1 " + ctx.pMEndX + " " + ctx.pMEndY + "\n        ");
			},

			m(target, anchor) {
				insertNode(path, target, anchor);
			},

			p(changed, ctx) {
				if (changed.id) {
					setAttribute(path, "id", ctx.id);
				}

				if ((changed.pMStartX || changed.pMStartY || changed.pMRadius || changed.arcSweep || changed.pMEndX || changed.pMEndY) && path_d_value !== (path_d_value = "\n          M " + ctx.pMStartX + " " + ctx.pMStartY + "\n          A " + ctx.pMRadius + " " + ctx.pMRadius + " 0 " + ctx.arcSweep + " 1 " + ctx.pMEndX + " " + ctx.pMEndY + "\n        ")) {
					setAttribute(path, "d", path_d_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(path);
				}
			}
		};
	}

	function Arc(options) {
		init(this, options);
		this._state = assign(assign({ Math : Math }, data()), options.data);
		this._recompute({ innerRadius: 1, centerX: 1, startRadians: 1, centerY: 1, endRadians: 1, outerRadius: 1, pMRadius: 1 }, this._state);
		this._intro = true;

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Arc.prototype, proto);

	Arc.prototype._recompute = function _recompute(changed, state) {
		if (changed.innerRadius || changed.centerX || changed.startRadians) {
			if (this._differs(state.p1x, (state.p1x = p1x(state)))) changed.p1x = true;
		}

		if (changed.innerRadius || changed.centerY || changed.startRadians) {
			if (this._differs(state.p1y, (state.p1y = p1y(state)))) changed.p1y = true;
		}

		if (changed.innerRadius || changed.centerX || changed.endRadians) {
			if (this._differs(state.p2x, (state.p2x = p2x(state)))) changed.p2x = true;
		}

		if (changed.innerRadius || changed.centerY || changed.endRadians) {
			if (this._differs(state.p2y, (state.p2y = p2y(state)))) changed.p2y = true;
		}

		if (changed.outerRadius || changed.centerX || changed.endRadians) {
			if (this._differs(state.p3x, (state.p3x = p3x(state)))) changed.p3x = true;
		}

		if (changed.outerRadius || changed.centerY || changed.endRadians) {
			if (this._differs(state.p3y, (state.p3y = p3y(state)))) changed.p3y = true;
		}

		if (changed.outerRadius || changed.centerX || changed.startRadians) {
			if (this._differs(state.p4x, (state.p4x = p4x(state)))) changed.p4x = true;
		}

		if (changed.outerRadius || changed.centerY || changed.startRadians) {
			if (this._differs(state.p4y, (state.p4y = p4y(state)))) changed.p4y = true;
		}

		if (changed.endRadians || changed.startRadians) {
			if (this._differs(state.arcSweep, (state.arcSweep = arcSweep(state)))) changed.arcSweep = true;
		}

		if (changed.innerRadius || changed.outerRadius) {
			if (this._differs(state.pMRadius, (state.pMRadius = pMRadius(state)))) changed.pMRadius = true;
		}

		if (changed.pMRadius || changed.centerX || changed.startRadians) {
			if (this._differs(state.pMStartX, (state.pMStartX = pMStartX(state)))) changed.pMStartX = true;
		}

		if (changed.pMRadius || changed.centerY || changed.startRadians) {
			if (this._differs(state.pMStartY, (state.pMStartY = pMStartY(state)))) changed.pMStartY = true;
		}

		if (changed.pMRadius || changed.centerX || changed.endRadians) {
			if (this._differs(state.pMEndX, (state.pMEndX = pMEndX(state)))) changed.pMEndX = true;
		}

		if (changed.pMRadius || changed.centerY || changed.endRadians) {
			if (this._differs(state.pMEndY, (state.pMEndY = pMEndY(state)))) changed.pMEndY = true;
		}
	};

	/* src/Goal.html generated by Svelte v2.7.2 */

	// TODO: Need to move this to import helpers.mjs so we can share this across components
	let translateX = (r, centerX, radians) => centerX + (r * Math.sin(radians));
	let translateY = (r, centerY, radians) => centerY - (r * Math.cos(radians));
	let getArcEnds = (r, centerX, centerY, startRadians, endRadians) => {
	  let p1x = translateX(r, centerX, startRadians);
	  let p1y = translateY(r, centerY, startRadians);
	  let p2x = translateX(r, centerX, endRadians);
	  let p2y = translateY(r, centerY, endRadians);
	  return {p1x, p1y, p2x, p2y}
	};

	function scale({goalAnnotated}) {
		return goalAnnotated.labelFontSize;
	}

	function p1x$1({goalAnnotated, centerX, startRadians}) {
		return translateX(goalAnnotated.radius, centerX, startRadians);
	}

	function p1y$1({goalAnnotated, centerY, startRadians}) {
		return translateY(goalAnnotated.radius, centerY, startRadians);
	}

	function p2x$1({goalAnnotated, centerX, endRadians}) {
		return translateX(goalAnnotated.radius, centerX, endRadians);
	}

	function p2y$1({goalAnnotated, centerY, endRadians}) {
		return translateY(goalAnnotated.radius, centerY, endRadians);
	}

	function arcSweep$1({endRadians, startRadians}) {
		return (endRadians - startRadians <= Math.PI) ? "0" : "1";
	}

	function labelArcEnds({goalAnnotated, centerX, centerY, startRadians, endRadians, scale}) {
	  return getArcEnds(goalAnnotated.radius - .75 * scale, centerX, centerY, startRadians, endRadians)
	}

	function data$1() {
	  return {
	    id: 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	        var r = crypto.getRandomValues(new Uint8Array(1))[0]%16|0, v = c == 'x' ? r : (r&0x3|0x8);
	        return v.toString(16)
	    }),
	    // scale: 1,
	  }
	}
	function create_main_fragment$1(component, ctx) {
		var g, path, path_stroke_value, path_d_value, text, textPath, text_1_value = ctx.goalAnnotated.label, text_1, textPath_xlink_href_value, textPath_fill_value, text_font_size_value;

		function select_block_type(ctx) {
			if ((ctx.startRadians >= ctx.Math.PI / 2) && (ctx.endRadians <= 3 * ctx.Math.PI / 2)) return create_if_block$1;
			return create_if_block_1$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c() {
				g = createSvgElement("g");
				path = createSvgElement("path");
				if_block.c();
				text = createSvgElement("text");
				textPath = createSvgElement("textPath");
				text_1 = createText(text_1_value);
				setAttribute(path, "fill", "none");
				setAttribute(path, "opacity", ctx.opacity);
				setAttribute(path, "stroke", path_stroke_value = ctx.goalAnnotated.goalColor);
				setAttribute(path, "stroke-width", .5);
				setAttribute(path, "stroke-linecap", "butt");
				setAttribute(path, "stroke-dasharray", "1, 0.5");
				setAttribute(path, "d", path_d_value = "\n      M " + ctx.p1x + " " + ctx.p1y + "\n      A " + ctx.goalAnnotated.radius + " " + ctx.goalAnnotated.radius + " 0 " + ctx.arcSweep + " 1 " + ctx.p2x + " " + ctx.p2y + "\n    ");
				setXlinkAttribute(textPath, "xlink:href", textPath_xlink_href_value = "#" + ctx.id);
				setAttribute(textPath, "dominant-baseline", "middle");
				setAttribute(textPath, "text-anchor", "middle");
				setAttribute(textPath, "startOffset", "50%");
				setAttribute(textPath, "fill", textPath_fill_value = ctx.goalAnnotated.goalColor);
				setAttribute(text, "font-size", text_font_size_value = ctx.goalAnnotated.labelFontSize);
			},

			m(target, anchor) {
				insertNode(g, target, anchor);
				appendNode(path, g);
				if_block.m(g, null);
				appendNode(text, g);
				appendNode(textPath, text);
				appendNode(text_1, textPath);
			},

			p(changed, ctx) {
				if (changed.opacity) {
					setAttribute(path, "opacity", ctx.opacity);
				}

				if ((changed.goalAnnotated) && path_stroke_value !== (path_stroke_value = ctx.goalAnnotated.goalColor)) {
					setAttribute(path, "stroke", path_stroke_value);
				}

				if ((changed.p1x || changed.p1y || changed.goalAnnotated || changed.arcSweep || changed.p2x || changed.p2y) && path_d_value !== (path_d_value = "\n      M " + ctx.p1x + " " + ctx.p1y + "\n      A " + ctx.goalAnnotated.radius + " " + ctx.goalAnnotated.radius + " 0 " + ctx.arcSweep + " 1 " + ctx.p2x + " " + ctx.p2y + "\n    ")) {
					setAttribute(path, "d", path_d_value);
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(g, text);
				}

				if ((changed.goalAnnotated) && text_1_value !== (text_1_value = ctx.goalAnnotated.label)) {
					text_1.data = text_1_value;
				}

				if ((changed.id) && textPath_xlink_href_value !== (textPath_xlink_href_value = "#" + ctx.id)) {
					setXlinkAttribute(textPath, "xlink:href", textPath_xlink_href_value);
				}

				if ((changed.goalAnnotated) && textPath_fill_value !== (textPath_fill_value = ctx.goalAnnotated.goalColor)) {
					setAttribute(textPath, "fill", textPath_fill_value);
				}

				if ((changed.goalAnnotated) && text_font_size_value !== (text_font_size_value = ctx.goalAnnotated.labelFontSize)) {
					setAttribute(text, "font-size", text_font_size_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(g);
				}

				if_block.d();
			}
		};
	}

	// (12:2) {#if (startRadians >= Math.PI / 2) && (endRadians <= 3 * Math.PI / 2)}
	function create_if_block$1(component, ctx) {
		var defs, path, path_d_value;

		return {
			c() {
				defs = createSvgElement("defs");
				path = createSvgElement("path");
				setAttribute(path, "id", ctx.id);
				setAttribute(path, "d", path_d_value = "\n          M " + ctx.labelArcEnds.p2x + " " + ctx.labelArcEnds.p2y + "\n          A " + ctx.goalAnnotated.radius + " " + ctx.goalAnnotated.radius + " 1 " + ctx.arcSweep + " 0 " + ctx.labelArcEnds.p1x + " " + ctx.labelArcEnds.p1y + "\n        ");
			},

			m(target, anchor) {
				insertNode(defs, target, anchor);
				appendNode(path, defs);
			},

			p(changed, ctx) {
				if (changed.id) {
					setAttribute(path, "id", ctx.id);
				}

				if ((changed.labelArcEnds || changed.goalAnnotated || changed.arcSweep) && path_d_value !== (path_d_value = "\n          M " + ctx.labelArcEnds.p2x + " " + ctx.labelArcEnds.p2y + "\n          A " + ctx.goalAnnotated.radius + " " + ctx.goalAnnotated.radius + " 1 " + ctx.arcSweep + " 0 " + ctx.labelArcEnds.p1x + " " + ctx.labelArcEnds.p1y + "\n        ")) {
					setAttribute(path, "d", path_d_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(defs);
				}
			}
		};
	}

	// (22:2) {:else}
	function create_if_block_1$1(component, ctx) {
		var defs, path, path_d_value;

		return {
			c() {
				defs = createSvgElement("defs");
				path = createSvgElement("path");
				setAttribute(path, "id", ctx.id);
				setAttribute(path, "d", path_d_value = "\n          M " + ctx.labelArcEnds.p1x + " " + ctx.labelArcEnds.p1y + "\n          A " + ctx.goalAnnotated.radius + " " + ctx.goalAnnotated.radius + " 0 " + ctx.arcSweep + " 1 " + ctx.labelArcEnds.p2x + " " + ctx.labelArcEnds.p2y + "\n        ");
			},

			m(target, anchor) {
				insertNode(defs, target, anchor);
				appendNode(path, defs);
			},

			p(changed, ctx) {
				if (changed.id) {
					setAttribute(path, "id", ctx.id);
				}

				if ((changed.labelArcEnds || changed.goalAnnotated || changed.arcSweep) && path_d_value !== (path_d_value = "\n          M " + ctx.labelArcEnds.p1x + " " + ctx.labelArcEnds.p1y + "\n          A " + ctx.goalAnnotated.radius + " " + ctx.goalAnnotated.radius + " 0 " + ctx.arcSweep + " 1 " + ctx.labelArcEnds.p2x + " " + ctx.labelArcEnds.p2y + "\n        ")) {
					setAttribute(path, "d", path_d_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(defs);
				}
			}
		};
	}

	function Goal(options) {
		init(this, options);
		this._state = assign(assign({ Math : Math }, data$1()), options.data);
		this._recompute({ goalAnnotated: 1, centerX: 1, startRadians: 1, centerY: 1, endRadians: 1, scale: 1 }, this._state);
		this._intro = true;

		this._fragment = create_main_fragment$1(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Goal.prototype, proto);

	Goal.prototype._recompute = function _recompute(changed, state) {
		if (changed.goalAnnotated) {
			if (this._differs(state.scale, (state.scale = scale(state)))) changed.scale = true;
		}

		if (changed.goalAnnotated || changed.centerX || changed.startRadians) {
			if (this._differs(state.p1x, (state.p1x = p1x$1(state)))) changed.p1x = true;
		}

		if (changed.goalAnnotated || changed.centerY || changed.startRadians) {
			if (this._differs(state.p1y, (state.p1y = p1y$1(state)))) changed.p1y = true;
		}

		if (changed.goalAnnotated || changed.centerX || changed.endRadians) {
			if (this._differs(state.p2x, (state.p2x = p2x$1(state)))) changed.p2x = true;
		}

		if (changed.goalAnnotated || changed.centerY || changed.endRadians) {
			if (this._differs(state.p2y, (state.p2y = p2y$1(state)))) changed.p2y = true;
		}

		if (changed.endRadians || changed.startRadians) {
			if (this._differs(state.arcSweep, (state.arcSweep = arcSweep$1(state)))) changed.arcSweep = true;
		}

		if (changed.goalAnnotated || changed.centerX || changed.centerY || changed.startRadians || changed.endRadians || changed.scale) {
			if (this._differs(state.labelArcEnds, (state.labelArcEnds = labelArcEnds(state)))) changed.labelArcEnds = true;
		}
	};

	/* src/Slice.html generated by Svelte v2.7.2 */

	function dataOuterRadius({outerRadius, labelBandHeight}) {
		return outerRadius - labelBandHeight;
	}

	function goalAnnotated({goal, innerRadius, dataOuterRadius}) {
	  let goalAnnotated = goal;
	  if (goal) {
	    if (goal.percentage) {
	      goalAnnotated.radius = innerRadius + (dataOuterRadius - innerRadius) * goal.percentage;
	    } else {
	      goalAnnotated.radius = dataOuterRadius;
	    }
	    if (! goal.label) {
	      //default label
	      goalAnnotated.label = "";
	    }
	    if (! goal.goalColor) {
	      //default color for goal line and text
	      goalAnnotated.goalColor = "#006de0";
	    }
	    if (! goal.labelFontSize) {
	      //default labelFontSize
	      goalAnnotated.labelFontSize = 2;
	    }
	  }
	  return goalAnnotated
	}

	function levelsAnnotated({levels, innerRadius, dataOuterRadius, levelConfigAnnotated}) {
	  let levelsAnnotated = [];
	  let total = 0;
	  for (let level of levels) {
	    total += level.portion;
	  }
	  let dataRangeRadius = dataOuterRadius - innerRadius;
	  let lastAnnotatedLevel = null;
	  let i = 0;
	  for (let level of levels) {
	    let currentAnnotatedLevel = {};
	    currentAnnotatedLevel.color = levelConfigAnnotated[i].color;
	    currentAnnotatedLevel.opacity = levelConfigAnnotated[i].opacity;
	    if (lastAnnotatedLevel) {
	      currentAnnotatedLevel.innerRadius = lastAnnotatedLevel.outerRadius;
	    } else {
	      currentAnnotatedLevel.innerRadius = innerRadius;
	    }
	    currentAnnotatedLevel.outerRadius = currentAnnotatedLevel.innerRadius + dataRangeRadius * (level.portion / total);
	    levelsAnnotated.push(currentAnnotatedLevel);
	    lastAnnotatedLevel = currentAnnotatedLevel;
	    i++;
	  }
	  return levelsAnnotated
	}

	function data$2() {
	  return {
	  }
	}
	function create_main_fragment$2(component, ctx) {
		var g, each_anchor;

		var arc_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.startRadians,
		 	endRadians: ctx.endRadians,
		 	innerRadius: ctx.dataOuterRadius,
		 	outerRadius: ctx.outerRadius,
		 	label: ctx.label,
		 	fontColor: ctx.fontColor,
		 	fontSize: ctx.fontSize,
		 	strokeWidth: ctx.strokeWidth,
		 	fill: "none",
		 	stroke: ctx.stroke
		 };
		var arc = new Arc({
			root: component.root,
			data: arc_initial_data
		});

		var each_value = ctx.levelsAnnotated;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		var arc_1_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.startRadians,
		 	endRadians: ctx.endRadians,
		 	innerRadius: ctx.innerRadius,
		 	outerRadius: ctx.dataOuterRadius,
		 	strokeWidth: ctx.strokeWidth,
		 	fill: "none",
		 	stroke: ctx.stroke
		 };
		var arc_1 = new Arc({
			root: component.root,
			data: arc_1_initial_data
		});

		var if_block = (ctx.goal) && create_if_block$2(component, ctx);

		return {
			c() {
				g = createSvgElement("g");
				arc._fragment.c();

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
				arc_1._fragment.c();
				if (if_block) if_block.c();
			},

			m(target, anchor) {
				insertNode(g, target, anchor);
				arc._mount(g, null);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(g, null);
				}

				appendNode(each_anchor, g);
				arc_1._mount(g, null);
				if (if_block) if_block.m(g, null);
			},

			p(changed, ctx) {
				var arc_changes = {};
				if (changed.centerX) arc_changes.centerX = ctx.centerX;
				if (changed.centerY) arc_changes.centerY = ctx.centerY;
				if (changed.startRadians) arc_changes.startRadians = ctx.startRadians;
				if (changed.endRadians) arc_changes.endRadians = ctx.endRadians;
				if (changed.dataOuterRadius) arc_changes.innerRadius = ctx.dataOuterRadius;
				if (changed.outerRadius) arc_changes.outerRadius = ctx.outerRadius;
				if (changed.label) arc_changes.label = ctx.label;
				if (changed.fontColor) arc_changes.fontColor = ctx.fontColor;
				if (changed.fontSize) arc_changes.fontSize = ctx.fontSize;
				if (changed.strokeWidth) arc_changes.strokeWidth = ctx.strokeWidth;
				if (changed.stroke) arc_changes.stroke = ctx.stroke;
				arc._set(arc_changes);

				if (changed.centerX || changed.centerY || changed.startRadians || changed.endRadians || changed.levelsAnnotated) {
					each_value = ctx.levelsAnnotated;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(g, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				var arc_1_changes = {};
				if (changed.centerX) arc_1_changes.centerX = ctx.centerX;
				if (changed.centerY) arc_1_changes.centerY = ctx.centerY;
				if (changed.startRadians) arc_1_changes.startRadians = ctx.startRadians;
				if (changed.endRadians) arc_1_changes.endRadians = ctx.endRadians;
				if (changed.innerRadius) arc_1_changes.innerRadius = ctx.innerRadius;
				if (changed.dataOuterRadius) arc_1_changes.outerRadius = ctx.dataOuterRadius;
				if (changed.strokeWidth) arc_1_changes.strokeWidth = ctx.strokeWidth;
				if (changed.stroke) arc_1_changes.stroke = ctx.stroke;
				arc_1._set(arc_1_changes);

				if (ctx.goal) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$2(component, ctx);
						if_block.c();
						if_block.m(g, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(g);
				}

				arc.destroy();

				destroyEach(each_blocks, detach);

				arc_1.destroy();
				if (if_block) if_block.d();
			}
		};
	}

	// (6:2) {#each levelsAnnotated as level}
	function create_each_block(component, ctx) {

		var arc_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.startRadians,
		 	endRadians: ctx.endRadians,
		 	innerRadius: ctx.level.innerRadius,
		 	outerRadius: ctx.level.outerRadius,
		 	fill: ctx.level.color,
		 	opacity: ctx.level.opacity,
		 	stroke: "none"
		 };
		var arc = new Arc({
			root: component.root,
			data: arc_initial_data
		});

		return {
			c() {
				arc._fragment.c();
			},

			m(target, anchor) {
				arc._mount(target, anchor);
			},

			p(changed, ctx) {
				var arc_changes = {};
				if (changed.centerX) arc_changes.centerX = ctx.centerX;
				if (changed.centerY) arc_changes.centerY = ctx.centerY;
				if (changed.startRadians) arc_changes.startRadians = ctx.startRadians;
				if (changed.endRadians) arc_changes.endRadians = ctx.endRadians;
				if (changed.levelsAnnotated) arc_changes.innerRadius = ctx.level.innerRadius;
				if (changed.levelsAnnotated) arc_changes.outerRadius = ctx.level.outerRadius;
				if (changed.levelsAnnotated) arc_changes.fill = ctx.level.color;
				if (changed.levelsAnnotated) arc_changes.opacity = ctx.level.opacity;
				arc._set(arc_changes);
			},

			d(detach) {
				arc.destroy(detach);
			}
		};
	}

	// (13:2) {#if goal}
	function create_if_block$2(component, ctx) {

		var goal_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.startRadians,
		 	endRadians: ctx.endRadians,
		 	goalAnnotated: ctx.goalAnnotated
		 };
		var goal = new Goal({
			root: component.root,
			data: goal_initial_data
		});

		return {
			c() {
				goal._fragment.c();
			},

			m(target, anchor) {
				goal._mount(target, anchor);
			},

			p(changed, ctx) {
				var goal_changes = {};
				if (changed.centerX) goal_changes.centerX = ctx.centerX;
				if (changed.centerY) goal_changes.centerY = ctx.centerY;
				if (changed.startRadians) goal_changes.startRadians = ctx.startRadians;
				if (changed.endRadians) goal_changes.endRadians = ctx.endRadians;
				if (changed.goalAnnotated) goal_changes.goalAnnotated = ctx.goalAnnotated;
				goal._set(goal_changes);
			},

			d(detach) {
				goal.destroy(detach);
			}
		};
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.level = list[i];
		child_ctx.each_value = list;
		child_ctx.level_index = i;
		return child_ctx;
	}

	function Slice(options) {
		init(this, options);
		this._state = assign(data$2(), options.data);
		this._recompute({ outerRadius: 1, labelBandHeight: 1, goal: 1, innerRadius: 1, dataOuterRadius: 1, levels: 1, levelConfigAnnotated: 1 }, this._state);
		this._intro = true;

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$2(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(Slice.prototype, proto);

	Slice.prototype._recompute = function _recompute(changed, state) {
		if (changed.outerRadius || changed.labelBandHeight) {
			if (this._differs(state.dataOuterRadius, (state.dataOuterRadius = dataOuterRadius(state)))) changed.dataOuterRadius = true;
		}

		if (changed.goal || changed.innerRadius || changed.dataOuterRadius) {
			if (this._differs(state.goalAnnotated, (state.goalAnnotated = goalAnnotated(state)))) changed.goalAnnotated = true;
		}

		if (changed.levels || changed.innerRadius || changed.dataOuterRadius || changed.levelConfigAnnotated) {
			if (this._differs(state.levelsAnnotated, (state.levelsAnnotated = levelsAnnotated(state)))) changed.levelsAnnotated = true;
		}
	};

	/* src/Legend.html generated by Svelte v2.7.2 */

	function junk(s) {
	  // console.log(s.fontSize)
	}

	function keySize({scale}) {
		return scale * 0.8;
	}

	function labelStartX({scale, legendStartX, keySize}) {
		return legendStartX + keySize + scale;
	}

	function textWidth({labelStartX}) {
		return 148 - labelStartX;
	}

	function descriptionStartX({labelStartX, labelDescriptionRatio, textWidth}) {
		return labelStartX + labelDescriptionRatio * textWidth;
	}

	function startY({levelConfigAnnotated, scale}) {
		return (100 - (2 * scale * levelConfigAnnotated.length)) / 2;
	}

	function data$3() {
	  return {
	    legendStartX: 102,
	    dirty: true,
	    scale: 1,
	    margin: 1.0 / 2,
	    labelDescriptionRatio: 1.0 / 4,
	    fontSize: 1,

	  }
	}
	function oncreate() {
	  let levelConfigAnnotated = this.get().levelConfigAnnotated;

	  let maxLabelWidth = 0;
	  let maxDescriptionWidth = 0;
	  for (var level of levelConfigAnnotated) {
	    level.labelWidth = document.getElementById(level.labelID).getBBox().width;
	    level.descriptionWidth = document.getElementById(level.descriptionID).getBBox().width;
	    if (level.labelWidth > maxLabelWidth) {
	      maxLabelWidth = level.labelWidth;
	    }
	    if (level.descriptionWidth > maxDescriptionWidth) {
	      maxDescriptionWidth = level.descriptionWidth;
	    }
	  }

	  let scale = this.get().textWidth / (maxLabelWidth + maxDescriptionWidth);
	  // if (scale > this.get().fontSize) {
	  //   scale = this.get().fontSize
	  // }

	  this.set({scale, labelDescriptionRatio: maxLabelWidth / maxDescriptionWidth});
	}
	function create_main_fragment$3(component, ctx) {
		var g;

		var each_value = ctx.levelConfigAnnotated;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		return {
			c() {
				g = createSvgElement("g");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},

			m(target, anchor) {
				insertNode(g, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(g, null);
				}
			},

			p(changed, ctx) {
				if (changed.legendStartX || changed.scale || changed.startY || changed.keySize || changed.levelConfigAnnotated || changed.practiceStroke || changed.strokeWidth || changed.labelStartX || changed.descriptionStartX) {
					each_value = ctx.levelConfigAnnotated;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(g, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(g);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (2:2) {#each levelConfigAnnotated as level, i}
	function create_each_block$1(component, ctx) {
		var rect, rect_x_value, rect_y_value, rect_fill_value, rect_fill_opacity_value, text, text_1_value = ctx.level.label, text_1, text_id_value, text_y_value, text_2, text_3_value = ctx.level.description, text_3, text_2_id_value, text_2_y_value;

		return {
			c() {
				rect = createSvgElement("rect");
				text = createSvgElement("text");
				text_1 = createText(text_1_value);
				text_2 = createSvgElement("text");
				text_3 = createText(text_3_value);
				setAttribute(rect, "x", rect_x_value = ctx.legendStartX+0.25*ctx.scale);
				setAttribute(rect, "y", rect_y_value = ctx.startY+ctx.i*2*ctx.scale+0.25*ctx.scale);
				setAttribute(rect, "height", ctx.keySize);
				setAttribute(rect, "width", ctx.keySize);
				setAttribute(rect, "fill", rect_fill_value = ctx.level.color);
				setAttribute(rect, "fill-opacity", rect_fill_opacity_value = ctx.level.opacity);
				setAttribute(rect, "stroke", ctx.practiceStroke);
				setAttribute(rect, "stroke-width", ctx.strokeWidth);
				setAttribute(text, "id", text_id_value = ctx.level.labelID);
				setAttribute(text, "x", ctx.labelStartX);
				setAttribute(text, "y", text_y_value = ctx.startY+ctx.i*2*ctx.scale+ctx.scale);
				setAttribute(text, "font-size", ctx.scale);
				setAttribute(text, "text-anchor", "left");
				setAttribute(text, "fill", "#006de0");
				setAttribute(text_2, "id", text_2_id_value = ctx.level.descriptionID);
				setAttribute(text_2, "x", ctx.descriptionStartX);
				setAttribute(text_2, "y", text_2_y_value = ctx.startY+ctx.i*2*ctx.scale+ctx.scale);
				setAttribute(text_2, "font-size", ctx.scale);
				setAttribute(text_2, "text-anchor", "left");
				setAttribute(text_2, "fill", "#006de0");
			},

			m(target, anchor) {
				insertNode(rect, target, anchor);
				insertNode(text, target, anchor);
				appendNode(text_1, text);
				insertNode(text_2, target, anchor);
				appendNode(text_3, text_2);
			},

			p(changed, ctx) {
				if ((changed.legendStartX || changed.scale) && rect_x_value !== (rect_x_value = ctx.legendStartX+0.25*ctx.scale)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if ((changed.startY || changed.scale) && rect_y_value !== (rect_y_value = ctx.startY+ctx.i*2*ctx.scale+0.25*ctx.scale)) {
					setAttribute(rect, "y", rect_y_value);
				}

				if (changed.keySize) {
					setAttribute(rect, "height", ctx.keySize);
					setAttribute(rect, "width", ctx.keySize);
				}

				if ((changed.levelConfigAnnotated) && rect_fill_value !== (rect_fill_value = ctx.level.color)) {
					setAttribute(rect, "fill", rect_fill_value);
				}

				if ((changed.levelConfigAnnotated) && rect_fill_opacity_value !== (rect_fill_opacity_value = ctx.level.opacity)) {
					setAttribute(rect, "fill-opacity", rect_fill_opacity_value);
				}

				if (changed.practiceStroke) {
					setAttribute(rect, "stroke", ctx.practiceStroke);
				}

				if (changed.strokeWidth) {
					setAttribute(rect, "stroke-width", ctx.strokeWidth);
				}

				if ((changed.levelConfigAnnotated) && text_1_value !== (text_1_value = ctx.level.label)) {
					text_1.data = text_1_value;
				}

				if ((changed.levelConfigAnnotated) && text_id_value !== (text_id_value = ctx.level.labelID)) {
					setAttribute(text, "id", text_id_value);
				}

				if (changed.labelStartX) {
					setAttribute(text, "x", ctx.labelStartX);
				}

				if ((changed.startY || changed.scale) && text_y_value !== (text_y_value = ctx.startY+ctx.i*2*ctx.scale+ctx.scale)) {
					setAttribute(text, "y", text_y_value);
				}

				if (changed.scale) {
					setAttribute(text, "font-size", ctx.scale);
				}

				if ((changed.levelConfigAnnotated) && text_3_value !== (text_3_value = ctx.level.description)) {
					text_3.data = text_3_value;
				}

				if ((changed.levelConfigAnnotated) && text_2_id_value !== (text_2_id_value = ctx.level.descriptionID)) {
					setAttribute(text_2, "id", text_2_id_value);
				}

				if (changed.descriptionStartX) {
					setAttribute(text_2, "x", ctx.descriptionStartX);
				}

				if ((changed.startY || changed.scale) && text_2_y_value !== (text_2_y_value = ctx.startY+ctx.i*2*ctx.scale+ctx.scale)) {
					setAttribute(text_2, "y", text_2_y_value);
				}

				if (changed.scale) {
					setAttribute(text_2, "font-size", ctx.scale);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(rect);
					detachNode(text);
					detachNode(text_2);
				}
			}
		};
	}

	function get_each_context$1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.level = list[i];
		child_ctx.each_value = list;
		child_ctx.i = i;
		return child_ctx;
	}

	function Legend(options) {
		init(this, options);
		this._state = assign(data$3(), options.data);
		this._recompute({ scale: 1, legendStartX: 1, keySize: 1, labelStartX: 1, labelDescriptionRatio: 1, textWidth: 1, levelConfigAnnotated: 1 }, this._state);
		this._intro = true;

		if (!options.root) {
			this._oncreate = [];
		}

		this._fragment = create_main_fragment$3(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			callAll(this._oncreate);
		}
	}

	assign(Legend.prototype, proto);

	Legend.prototype._recompute = function _recompute(changed, state) {
		if (changed.scale) {
			if (this._differs(state.keySize, (state.keySize = keySize(state)))) changed.keySize = true;
		}

		if (changed.scale || changed.legendStartX || changed.keySize) {
			if (this._differs(state.labelStartX, (state.labelStartX = labelStartX(state)))) changed.labelStartX = true;
		}

		if (changed.labelStartX) {
			if (this._differs(state.textWidth, (state.textWidth = textWidth(state)))) changed.textWidth = true;
		}

		if (changed.labelStartX || changed.labelDescriptionRatio || changed.textWidth) {
			if (this._differs(state.descriptionStartX, (state.descriptionStartX = descriptionStartX(state)))) changed.descriptionStartX = true;
		}

		if (changed.levelConfigAnnotated || changed.scale) {
			if (this._differs(state.startY, (state.startY = startY(state)))) changed.startY = true;
		}

		if (this._differs(state.junk, (state.junk = junk(state)))) changed.junk = true;
	};

	/* src/Radar.html generated by Svelte v2.7.2 */

	let getID = () =>
	  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	     var r = crypto.getRandomValues(new Uint8Array(1))[0]%16|0, v = c == 'x' ? r : (r&0x3|0x8);
	     return v.toString(16)
	   });

	 function practiceCount({disciplines}) {
	  let practiceCount = 0;
	  for (let discipline of disciplines) {
	    for (let practice of discipline.practices) {
	      practiceCount++;
	    }
	  }
	  return practiceCount
	}

	function sliceWidth({practiceCount}) {
		return Math.PI * 2 / practiceCount;
	}

	function disciplineMaxWidth({outerRadius, disciplineBandHeight, sliceWidth}) {
		return 0.75 * sliceWidth * (outerRadius - disciplineBandHeight / 2);
	}

	function practiceMaxWidth({outerRadius, disciplineBandHeight, practiceBandHeight, sliceWidth}) {
		return 0.75 * sliceWidth * (outerRadius - disciplineBandHeight - practiceBandHeight / 2);
	}

	function disciplineMaxHeight({disciplineBandHeight}) {
		return 0.75 * disciplineBandHeight;
	}

	function practiceMaxHeight({practiceBandHeight}) {
		return 0.75 * practiceBandHeight;
	}

	function disciplinesAnnotated({disciplines, outerRadius, disciplineBandHeight, sliceWidth}) {
	  let disciplinesAnnotated = disciplines;

	  let currentAngle = 0;
	  for (let discipline of disciplines) {
	    discipline.id = getID();
	    discipline.startRadians = currentAngle;
	    for (let practice of discipline.practices) {
	      practice.id = getID();
	      practice.startRadians = currentAngle;
	      currentAngle += sliceWidth;
	      practice.endRadians = currentAngle;
	    }
	    discipline.endRadians = currentAngle;
	  }

	  return disciplinesAnnotated
	}

	function levelConfigAnnotated({levelConfig, baseColor}) {
	  let levelConfigAnnotated = [];
	  let baseColorCount = 0;
	  for (let level of levelConfig) {
	    if (! level.color)
	      baseColorCount++;
	  }
	  let i = 0;
	  for (let level of levelConfig) {
	    if (! level.color) {
	      level.color = baseColor;
	      level.opacity = (baseColorCount - i - 1) / (baseColorCount - 1);
	    } else {
	      level.opacity = 1;
	    }
	    if (! level.description) {
	      level.description = "";
	    }
	    level.labelID = getID();
	    level.descriptionID = getID();
	    levelConfigAnnotated.push(level);
	    i++;
	  }
	  return levelConfigAnnotated
	}

	function data$4() {
	  return {
	    centerX: 50,
	    centerY: 50,
	    practiceStroke: "#999999",
	    disciplineStroke: "#555555",
	    strokeWidth: 0.15,
	    baseColor: "#2E8468",
	    fontColor: "#22644E",
	    practiceFontSize: 1,
	    disciplineFontSize: 1,
	    goalFontSize: 1,
	    diciplineFontColor: "#184738",
	    innerRadius: 10,
	    outerRadius: 49,
	    disciplineBandHeight: 7,
	    practiceBandHeight: 5,
	    disciplines: [
	      {
	        discipline: "No data",
	        practices: [
	          {practice: "Instructions: https://github.com/morganmaccherone/matrx-radar/blob/master/README.md", levels: [
	            {portion: 1},
	          ]},
	        ]
	      },
	      {
	        discipline: "No data",
	        practices: [
	          {practice: "Editable example: TBD", levels: [
	            {portion: 1},
	          ]},
	        ]
	      },
	    ]
	  }
	}
	function oncreate$1() {
	  let disciplinesAnnotated = this.get().disciplinesAnnotated;

	  let maxPracticeWidth = 0;
	  let maxPracticeHeight = 0;
	  let maxDisciplineWidth = 0;
	  let maxDisciplineHeight = 0;

	  for (let discipline of disciplinesAnnotated) {
	    maxDisciplineWidth = Math.max(maxDisciplineWidth, document.getElementById(discipline.id).getBBox().width);
	    maxDisciplineHeight = Math.max(maxDisciplineHeight, document.getElementById(discipline.id).getBBox().height);
	    for (let practice of discipline.practices) {
	      maxPracticeWidth = Math.max(maxPracticeWidth, document.getElementById(practice.id).getBBox().width);
	      maxPracticeHeight = Math.max(maxPracticeHeight, document.getElementById(practice.id).getBBox().height);
	    }
	  }

	  let practiceFontSize = Math.min(this.get().practiceMaxWidth / maxPracticeWidth, this.get().practiceMaxHeight / maxPracticeHeight);
	  let disciplineFontSize = Math.min(this.get().disciplineMaxWidth / maxDisciplineWidth, this.get().disciplineMaxHeight / maxDisciplineHeight);

	  if (practiceFontSize > disciplineFontSize) {
	    practiceFontSize = disciplineFontSize;
	  }

	  this.set({disciplineFontSize, practiceFontSize});

	}
	function create_main_fragment$4(component, ctx) {
		var svg, each_anchor;

		var each_value = ctx.disciplinesAnnotated;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(component, get_each_context$2(ctx, each_value, i));
		}

		var legend_initial_data = {
		 	levelConfigAnnotated: ctx.levelConfigAnnotated,
		 	fontSize: ctx.disciplineFontSize,
		 	strokeWidth: ctx.strokeWidth,
		 	practiceStroke: ctx.practiceStroke
		 };
		var legend = new Legend({
			root: component.root,
			data: legend_initial_data
		});

		return {
			c() {
				svg = createSvgElement("svg");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
				legend._fragment.c();
				setAttribute(svg, "version", "1.1");
				setAttribute(svg, "viewBox", "0 0 150 100");
				setAttribute(svg, "preserveAspectRatio", "xMinYMin meet");
			},

			m(target, anchor) {
				insertNode(svg, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(svg, null);
				}

				appendNode(each_anchor, svg);
				legend._mount(svg, null);
			},

			p(changed, ctx) {
				if (changed.disciplinesAnnotated || changed.disciplineFontSize || changed.practiceFontSize || changed.centerX || changed.centerY || changed.innerRadius || changed.outerRadius || changed.disciplineBandHeight || changed.practiceBandHeight || changed.practiceStroke || changed.strokeWidth || changed.fontColor || changed.levelConfigAnnotated || changed.disciplineStroke || changed.diciplineFontColor) {
					each_value = ctx.disciplinesAnnotated;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$2(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(svg, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				var legend_changes = {};
				if (changed.levelConfigAnnotated) legend_changes.levelConfigAnnotated = ctx.levelConfigAnnotated;
				if (changed.disciplineFontSize) legend_changes.fontSize = ctx.disciplineFontSize;
				if (changed.strokeWidth) legend_changes.strokeWidth = ctx.strokeWidth;
				if (changed.practiceStroke) legend_changes.practiceStroke = ctx.practiceStroke;
				legend._set(legend_changes);
			},

			d(detach) {
				if (detach) {
					detachNode(svg);
				}

				destroyEach(each_blocks, detach);

				legend.destroy();
			}
		};
	}

	// (3:2) {#each disciplinesAnnotated as discipline}
	function create_each_block$2(component, ctx) {
		var text, text_1_value = ctx.discipline.discipline, text_1, text_id_value, each_anchor;

		var each_value_1 = ctx.discipline.practices;

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(component, get_each_context_1(ctx, each_value_1, i));
		}

		var arc_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.discipline.startRadians,
		 	endRadians: ctx.discipline.endRadians,
		 	innerRadius: ctx.outerRadius-ctx.disciplineBandHeight,
		 	outerRadius: ctx.outerRadius,
		 	labelBandHeight: ctx.disciplineBandHeight,
		 	fill: "none",
		 	strokeWidth: ctx.strokeWidth * 2,
		 	stroke: ctx.disciplineStroke,
		 	label: ctx.discipline.discipline,
		 	fontColor: ctx.diciplineFontColor,
		 	fontSize: ctx.disciplineFontSize
		 };
		var arc = new Arc({
			root: component.root,
			data: arc_initial_data
		});

		var arc_1_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.discipline.startRadians,
		 	endRadians: ctx.discipline.endRadians,
		 	outerRadius: ctx.outerRadius,
		 	innerRadius: ctx.innerRadius,
		 	fill: "none",
		 	strokeWidth: ctx.strokeWidth * 2,
		 	stroke: ctx.disciplineStroke
		 };
		var arc_1 = new Arc({
			root: component.root,
			data: arc_1_initial_data
		});

		return {
			c() {
				text = createSvgElement("text");
				text_1 = createText(text_1_value);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
				arc._fragment.c();
				arc_1._fragment.c();
				setAttribute(text, "dy", "-100");
				setAttribute(text, "id", text_id_value = ctx.discipline.id);
				setAttribute(text, "font-size", ctx.disciplineFontSize);
			},

			m(target, anchor) {
				insertNode(text, target, anchor);
				appendNode(text_1, text);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insertNode(each_anchor, target, anchor);
				arc._mount(target, anchor);
				arc_1._mount(target, anchor);
			},

			p(changed, ctx) {
				if ((changed.disciplinesAnnotated) && text_1_value !== (text_1_value = ctx.discipline.discipline)) {
					text_1.data = text_1_value;
				}

				if ((changed.disciplinesAnnotated) && text_id_value !== (text_id_value = ctx.discipline.id)) {
					setAttribute(text, "id", text_id_value);
				}

				if (changed.disciplineFontSize) {
					setAttribute(text, "font-size", ctx.disciplineFontSize);
				}

				if (changed.disciplinesAnnotated || changed.practiceFontSize || changed.centerX || changed.centerY || changed.innerRadius || changed.outerRadius || changed.disciplineBandHeight || changed.practiceBandHeight || changed.practiceStroke || changed.strokeWidth || changed.fontColor || changed.levelConfigAnnotated) {
					each_value_1 = ctx.discipline.practices;

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}

				var arc_changes = {};
				if (changed.centerX) arc_changes.centerX = ctx.centerX;
				if (changed.centerY) arc_changes.centerY = ctx.centerY;
				if (changed.disciplinesAnnotated) arc_changes.startRadians = ctx.discipline.startRadians;
				if (changed.disciplinesAnnotated) arc_changes.endRadians = ctx.discipline.endRadians;
				if (changed.outerRadius || changed.disciplineBandHeight) arc_changes.innerRadius = ctx.outerRadius-ctx.disciplineBandHeight;
				if (changed.outerRadius) arc_changes.outerRadius = ctx.outerRadius;
				if (changed.disciplineBandHeight) arc_changes.labelBandHeight = ctx.disciplineBandHeight;
				if (changed.strokeWidth) arc_changes.strokeWidth = ctx.strokeWidth * 2;
				if (changed.disciplineStroke) arc_changes.stroke = ctx.disciplineStroke;
				if (changed.disciplinesAnnotated) arc_changes.label = ctx.discipline.discipline;
				if (changed.diciplineFontColor) arc_changes.fontColor = ctx.diciplineFontColor;
				if (changed.disciplineFontSize) arc_changes.fontSize = ctx.disciplineFontSize;
				arc._set(arc_changes);

				var arc_1_changes = {};
				if (changed.centerX) arc_1_changes.centerX = ctx.centerX;
				if (changed.centerY) arc_1_changes.centerY = ctx.centerY;
				if (changed.disciplinesAnnotated) arc_1_changes.startRadians = ctx.discipline.startRadians;
				if (changed.disciplinesAnnotated) arc_1_changes.endRadians = ctx.discipline.endRadians;
				if (changed.outerRadius) arc_1_changes.outerRadius = ctx.outerRadius;
				if (changed.innerRadius) arc_1_changes.innerRadius = ctx.innerRadius;
				if (changed.strokeWidth) arc_1_changes.strokeWidth = ctx.strokeWidth * 2;
				if (changed.disciplineStroke) arc_1_changes.stroke = ctx.disciplineStroke;
				arc_1._set(arc_1_changes);
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}

				arc.destroy(detach);
				arc_1.destroy(detach);
			}
		};
	}

	// (9:4) {#each discipline.practices as practice}
	function create_each_block_1(component, ctx) {
		var text, text_1_value = ctx.practice.practice, text_1, text_id_value;

		var slice_initial_data = {
		 	centerX: ctx.centerX,
		 	centerY: ctx.centerY,
		 	startRadians: ctx.practice.startRadians,
		 	endRadians: ctx.practice.endRadians,
		 	innerRadius: ctx.innerRadius,
		 	outerRadius: ctx.outerRadius-ctx.disciplineBandHeight,
		 	levels: ctx.practice.levels,
		 	label: ctx.practice.practice,
		 	goal: ctx.practice.goal,
		 	labelBandHeight: ctx.practiceBandHeight,
		 	stroke: ctx.practiceStroke,
		 	strokeWidth: ctx.strokeWidth,
		 	fontColor: ctx.fontColor,
		 	fontSize: ctx.practiceFontSize,
		 	levelConfigAnnotated: ctx.levelConfigAnnotated
		 };
		var slice = new Slice({
			root: component.root,
			data: slice_initial_data
		});

		return {
			c() {
				text = createSvgElement("text");
				text_1 = createText(text_1_value);
				slice._fragment.c();
				setAttribute(text, "dy", "-100");
				setAttribute(text, "id", text_id_value = ctx.practice.id);
				setAttribute(text, "font-size", ctx.practiceFontSize);
			},

			m(target, anchor) {
				insertNode(text, target, anchor);
				appendNode(text_1, text);
				slice._mount(target, anchor);
			},

			p(changed, ctx) {
				if ((changed.disciplinesAnnotated) && text_1_value !== (text_1_value = ctx.practice.practice)) {
					text_1.data = text_1_value;
				}

				if ((changed.disciplinesAnnotated) && text_id_value !== (text_id_value = ctx.practice.id)) {
					setAttribute(text, "id", text_id_value);
				}

				if (changed.practiceFontSize) {
					setAttribute(text, "font-size", ctx.practiceFontSize);
				}

				var slice_changes = {};
				if (changed.centerX) slice_changes.centerX = ctx.centerX;
				if (changed.centerY) slice_changes.centerY = ctx.centerY;
				if (changed.disciplinesAnnotated) slice_changes.startRadians = ctx.practice.startRadians;
				if (changed.disciplinesAnnotated) slice_changes.endRadians = ctx.practice.endRadians;
				if (changed.innerRadius) slice_changes.innerRadius = ctx.innerRadius;
				if (changed.outerRadius || changed.disciplineBandHeight) slice_changes.outerRadius = ctx.outerRadius-ctx.disciplineBandHeight;
				if (changed.disciplinesAnnotated) slice_changes.levels = ctx.practice.levels;
				if (changed.disciplinesAnnotated) slice_changes.label = ctx.practice.practice;
				if (changed.disciplinesAnnotated) slice_changes.goal = ctx.practice.goal;
				if (changed.practiceBandHeight) slice_changes.labelBandHeight = ctx.practiceBandHeight;
				if (changed.practiceStroke) slice_changes.stroke = ctx.practiceStroke;
				if (changed.strokeWidth) slice_changes.strokeWidth = ctx.strokeWidth;
				if (changed.fontColor) slice_changes.fontColor = ctx.fontColor;
				if (changed.practiceFontSize) slice_changes.fontSize = ctx.practiceFontSize;
				if (changed.levelConfigAnnotated) slice_changes.levelConfigAnnotated = ctx.levelConfigAnnotated;
				slice._set(slice_changes);
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}

				slice.destroy(detach);
			}
		};
	}

	function get_each_context$2(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.discipline = list[i];
		child_ctx.each_value = list;
		child_ctx.discipline_index = i;
		return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.practice = list[i];
		child_ctx.each_value_1 = list;
		child_ctx.practice_index = i;
		return child_ctx;
	}

	function Radar(options) {
		init(this, options);
		this._state = assign(data$4(), options.data);
		this._recompute({ disciplines: 1, practiceCount: 1, outerRadius: 1, disciplineBandHeight: 1, sliceWidth: 1, practiceBandHeight: 1, levelConfig: 1, baseColor: 1 }, this._state);
		this._intro = true;

		if (!options.root) {
			this._oncreate = [];
			this._beforecreate = [];
			this._aftercreate = [];
		}

		this._fragment = create_main_fragment$4(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$1.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			this._lock = true;
			callAll(this._beforecreate);
			callAll(this._oncreate);
			callAll(this._aftercreate);
			this._lock = false;
		}
	}

	assign(Radar.prototype, proto);

	Radar.prototype._recompute = function _recompute(changed, state) {
		if (changed.disciplines) {
			if (this._differs(state.practiceCount, (state.practiceCount = practiceCount(state)))) changed.practiceCount = true;
		}

		if (changed.practiceCount) {
			if (this._differs(state.sliceWidth, (state.sliceWidth = sliceWidth(state)))) changed.sliceWidth = true;
		}

		if (changed.outerRadius || changed.disciplineBandHeight || changed.sliceWidth) {
			if (this._differs(state.disciplineMaxWidth, (state.disciplineMaxWidth = disciplineMaxWidth(state)))) changed.disciplineMaxWidth = true;
		}

		if (changed.outerRadius || changed.disciplineBandHeight || changed.practiceBandHeight || changed.sliceWidth) {
			if (this._differs(state.practiceMaxWidth, (state.practiceMaxWidth = practiceMaxWidth(state)))) changed.practiceMaxWidth = true;
		}

		if (changed.disciplineBandHeight) {
			if (this._differs(state.disciplineMaxHeight, (state.disciplineMaxHeight = disciplineMaxHeight(state)))) changed.disciplineMaxHeight = true;
		}

		if (changed.practiceBandHeight) {
			if (this._differs(state.practiceMaxHeight, (state.practiceMaxHeight = practiceMaxHeight(state)))) changed.practiceMaxHeight = true;
		}

		if (changed.disciplines || changed.outerRadius || changed.disciplineBandHeight || changed.sliceWidth) {
			if (this._differs(state.disciplinesAnnotated, (state.disciplinesAnnotated = disciplinesAnnotated(state)))) changed.disciplinesAnnotated = true;
		}

		if (changed.levelConfig || changed.baseColor) {
			if (this._differs(state.levelConfigAnnotated, (state.levelConfigAnnotated = levelConfigAnnotated(state)))) changed.levelConfigAnnotated = true;
		}
	};

	return Radar;

})));
//# sourceMappingURL=matrx-radar.js.map
